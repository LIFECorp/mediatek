#include <Tfa9887.h>
#include <Tfa9887_Registers.h>
#include <assert.h>
#include <string.h>
#ifdef WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <sys/stat.h>
#include <NXP_I2C.h>
#ifndef WIN32
// need PIN access
#include <inttypes.h>
#include <lxScribo.h>
#endif

//#define SPDIF_AUDIO
#define USB_AUDIO


#ifndef WIN32

#define Sleep(ms) usleep((ms)*1000)
#define _fileno fileno
#define _GNU_SOURCE   /* to avoid link issues with sscanf on NxDI? */
#endif

#define I2C_ADDRESS  0x6E
#define SAMPLE_RATE 48000

#ifdef WIN32
// cwd = dir where vcxproj is
#define LOCATION_FILES "../../../settings/"
#else
// cwd = linux dir
#define LOCATION_FILES "../win/exTfa9887/"
#endif

#define PATCH_FILENAME "TFA9887_N1D2_2_4_1.patch"

/* the base speaker file, containing tCoef */
#define SPEAKER_FILENAME "KS_13X18_DUMBO_tCoef.speaker"
#define PRESET_FILENAME "HQ_KS_13X18_DUMBO.preset"
#define CONFIG_FILENAME "TFA9887_N1D2.config"
#define EQ_FILENAME "HQ_KS_13X18_DUMBO.eq"
//#define EQ_FILENAME "Rock.eq"

static float tCoefFromSpeaker(Tfa98xx_SpeakerParameters_t speakerBytes)
{
	int iCoef;

	/* tCoef(A) is the last parameter of the speaker */
	iCoef = (speakerBytes[TFA9887_SPEAKERPARAMETER_LENGTH-3]<<16) + (speakerBytes[TFA9887_SPEAKERPARAMETER_LENGTH-2]<<8) + speakerBytes[TFA9887_SPEAKERPARAMETER_LENGTH-1];

	return (float)iCoef/(1<<23);
}

static void tCoefToSpeaker(Tfa98xx_SpeakerParameters_t speakerBytes, float tCoef)
{
	int iCoef;

	iCoef =(int)(tCoef*(1<<23));

	speakerBytes[TFA9887_SPEAKERPARAMETER_LENGTH-3] = (iCoef>>16)&0xFF;
	speakerBytes[TFA9887_SPEAKERPARAMETER_LENGTH-2] = (iCoef>>8)&0xFF;
	speakerBytes[TFA9887_SPEAKERPARAMETER_LENGTH-1] = (iCoef)&0xFF;
}

static void muteAmplifier(Tfa9887_handle_t handle)
{
	Tfa9887_Error_t err;
	unsigned short status;

	/* signal the TFA9887 to mute plop free and turn off the amplifier */
	err = Tfa9887_SetMute(handle, Tfa9887_Mute_Amplifier);
	assert(err == Tfa9887_Error_Ok);

	/* now wait for the amplifier to turn off */
	err = Tfa9887_ReadRegister16(handle, TFA9887_STATUSREG, &status);
	assert(err == Tfa9887_Error_Ok);
	while ( (status & TFA9887_STATUS_SWS) == TFA9887_STATUS_SWS)
	{
		err = Tfa9887_ReadRegister16(handle, TFA9887_STATUSREG, &status);
		assert(err == Tfa9887_Error_Ok);
	}
}

static void loadSpeakerFile(const char* fileName, Tfa9887_SpeakerParameters_t speakerBytes)
{
	int ret;
	FILE* f;

	printf("using speaker %s\n", fileName);

	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fread(speakerBytes, 1, sizeof(Tfa9887_SpeakerParameters_t), f);
	assert(ret == sizeof(Tfa9887_SpeakerParameters_t));
	fclose(f);
}

/* load a speaker model from a file, as generated by the GUI, or saved from a previous execution */
static void setSpeaker(Tfa9887_handle_t handle, const char* fileName, Tfa9887_SpeakerParameters_t speakerBytes)
{
	Tfa9887_Error_t err;
	int ret;
	FILE* f;

	printf("using speaker %s\n", fileName);

	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fread(speakerBytes, 1, sizeof(Tfa9887_SpeakerParameters_t), f);
	assert(ret == sizeof(Tfa9887_SpeakerParameters_t));
	err = Tfa9887_DspWriteSpeakerParameters(handle, speakerBytes);
	assert(err == Tfa9887_Error_Ok);
	fclose(f);
}
/* save the current speaker model to a file, for future use */
static void saveSpeaker(Tfa9887_SpeakerParameters_t speakerBytes, const char* fileName)
{
	int ret;
	FILE* f;

	f=fopen(fileName, "wb");
	assert(f!=NULL);
	ret = fwrite(speakerBytes, 1, sizeof(Tfa9887_SpeakerParameters_t), f);
	assert(ret == sizeof(Tfa9887_SpeakerParameters_t));
	fclose(f);
}

static void setConfig(Tfa9887_handle_t handle, const char* fileName)
{
	Tfa9887_Error_t err;
	Tfa9887_Config_t config;
	int ret;
	FILE* f;

	printf("using config %s\n", fileName);


	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fread(config, 1, sizeof(config), f);
	assert(ret == TFA9887_CONFIG_LENGTH);
	err = Tfa9887_DspWriteConfig(handle, config);
	assert(err == Tfa9887_Error_Ok);
	fclose(f);
}

/* load a preset from a file, as generated by the GUI, can be done at runtime */
static void setPreset(Tfa9887_handle_t handle, const char* fileName)
{
	int ret;
	int presetSize;
	unsigned char* buffer;
	FILE* f;
	struct stat st;
	Tfa9887_Error_t err;

	printf("using preset %s\n", fileName);

	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fstat(_fileno(f), &st);
	assert(ret == 0);
	presetSize = st.st_size;
	assert(presetSize == TFA9887_PRESET_LENGTH);
	buffer = (unsigned char*)malloc(presetSize);
	assert(buffer != NULL);
	ret = fread(buffer, 1, presetSize, f);
	assert(ret == presetSize);
	err = Tfa9887_DspWritePreset(handle, buffer);
	assert(err == Tfa9887_Error_Ok);
	fclose(f);
	free(buffer);
}

/* load a set of EQ settings from a file, as generated by the GUI, can be done at runtime */
static void setEQ(Tfa9887_handle_t handle, const char* fileName)
{
	int ret;
	FILE* f;
	Tfa9887_Error_t err;
	int ind; /* biquad index */
	float b0, b1, b2, a1, a2; /* the coefficients */
	int line = 1;
	char buffer[256];

	printf("using EQ %s\n", fileName);

	f=fopen(fileName, "rb");
	assert(f!=NULL);

	while (!feof(f))
	{
		if (NULL == fgets(buffer, sizeof(buffer)-1, f) )
		{
			break;
		}
		ret = sscanf(buffer, "%d %f %f %f %f %f", &ind, &b0, &b1, &b2, &a1, &a2);
		if (ret == 6)
		{
			if ((b0 != 1) || (b1 != 0) || (b2 != 0) || (a1 != 0) || (a2 != 0)) {
				err = Tfa9887_DspBiquad_SetCoeff(handle, ind, b0, b1, b2, a1, a2);
				assert(err == Tfa9887_Error_Ok);
				printf("Loaded biquad %d\n", ind);
      } else {
        err = Tfa9887_DspBiquad_Disable(handle, ind);
				assert(err == Tfa9887_Error_Ok);
				printf("Disabled biquad %d\n", ind);
			}
		}
		else {
			printf("error parsing file, line %d\n", line);
			//break;
		}
		line++;
	}
	fclose(f);
}

/* load a DSP ROM code patch from file */
static void dspPatch(Tfa9887_handle_t handle, const char* fileName)
{
	int ret;
	int fileSize;
	unsigned char* buffer;
	FILE* f;
	struct stat st;
	Tfa9887_Error_t err;

	f=fopen(fileName, "rb");
	assert(f!=NULL);
	ret = fstat(_fileno(f), &st);
	assert(ret == 0);
	fileSize = st.st_size;
	buffer = malloc(fileSize);
	assert(buffer != NULL);
	ret = fread(buffer, 1, fileSize, f);
	assert(ret == fileSize);
	err = Tfa9887_DspPatch(handle, fileSize, buffer);
	assert(err == Tfa9887_Error_Ok);
	fclose(f);
	free(buffer);
}

static char* stateFlagsStr(int stateFlags)
{
	static char flags[10];

	flags[0] = (stateFlags & (0x1<<Tfa9887_SpeakerBoost_Activity)) ? 'A':'a';
	flags[1] = (stateFlags & (0x1<<Tfa9887_SpeakerBoost_S_Ctrl)) ? 'S':'s';
	flags[2] = (stateFlags & (0x1<<Tfa9887_SpeakerBoost_Muted)) ? 'M':'m';
	flags[3] = (stateFlags & (0x1<<Tfa9887_SpeakerBoost_X_Ctrl)) ? 'X':'x';
	flags[4] = (stateFlags & (0x1<<Tfa9887_SpeakerBoost_T_Ctrl)) ? 'T':'t';
	flags[5] = (stateFlags & (0x1<<Tfa9887_SpeakerBoost_NewModel)) ? 'L':'l';
	flags[6] = (stateFlags & (0x1<<Tfa9887_SpeakerBoost_VolumeRdy)) ? 'V':'v';
	flags[7] = (stateFlags & (0x1<<Tfa9887_SpeakerBoost_Damaged)) ? 'D':'d';
	flags[8] = (stateFlags & (0x1<<Tfa9887_SpeakerBoost_SignalClipping)) ? 'C':'c';

	flags[9] = 0;
	return flags;
}

static void dump_state_info(Tfa9887_SpeakerBoost_StateInfo_t* pState)
{
  printf("state: flags %s, agcGain %2.1f\tlimGain %2.1f\tsMax %2.1f\tT %d\tX1 %2.1f\tX2 %2.1f\tRe %2.2f\n",
				stateFlagsStr(pState->statusFlag),
				pState->agcGain,
				pState->limGain,
				pState->sMax,
				pState->T,
				pState->X1,
				pState->X2,
				pState->Re);
}

static void load_all_settings(Tfa9887_handle_t handle, Tfa9887_SpeakerParameters_t speakerBytes, const char* configFile, const char* presetFile, const char* eqFile)
{
	Tfa9887_Error_t err;

	/* load fullmodel */
	err = Tfa9887_DspWriteSpeakerParameters(handle, speakerBytes);
	assert(err == Tfa9887_Error_Ok);

	/* load the settings */
	setConfig(handle, configFile);
	/* load a preset */
	setPreset(handle, presetFile);
    /* load an EQ file */
	setEQ(handle, eqFile);
}

static void waitCalibration(Tfa98xx_handle_t handle, int *calibrateDone)
{
	Tfa9887_Error_t err;
	int tries = 0;
	unsigned short mtp;
#define WAIT_TRIES 1000

	err = Tfa98xx_ReadRegister16(handle, TFA9887_MTP, &mtp);

	/* in case of calibrate once wait for MTPEX */
	if ( mtp & TFA9887_MTP_MTPOTC) {
		while ( (*calibrateDone == 0) && (tries < TFA98XX_API_WAITRESULT_NTRIES))
		{	// TODO optimise with wait estimation
			err = Tfa9887_ReadRegister16(handle, TFA9887_MTP, &mtp);
			*calibrateDone = ( mtp & TFA9887_MTP_MTPEX);	/* check MTP bit1 (MTPEX) */
			tries++;
		}
	} else /* poll xmem for calibrate always */
	{
		while ((*calibrateDone == 0) && (tries<WAIT_TRIES) )
		{	// TODO optimise with wait estimation
			err = Tfa9887_DspReadMem(handle, 231, 1, calibrateDone);
			tries++;
		}
		if(tries==WAIT_TRIES)
			printf("calibrateDone 231 timedout\n");
	}

}

#ifdef SPDIF_AUDIO
typedef int  (__stdcall *SetPin_type)(unsigned char pinNumber, unsigned short value);
static SetPin_type SetPin;

void InitSpdifAudio()
{
  HMODULE hDll;
	unsigned char i2c_UDAmode2[] = {0x34, 0x00, 0x28, 0x2E};
	unsigned char i2c_UDAI2SSpdif[] = {0x34, 0x50, 0x01, 0x51};

	/* copied the relevant code from C:\Program Files\NXP\I2C\C\CrdI2c.c
	 */
	hDll = LoadLibrary(L"Scribo.dll");
	if (hDll == 0) {
		fprintf(stderr, "Could not open Scribo.dll\n");
		return ;
	}

	SetPin = (SetPin_type) GetProcAddress(hDll, "SetPin");
	if (SetPin == NULL) {
		FreeLibrary(hDll);
		return; // function not found in library
	}

	SetPin(4, 0x1); /* Weak pull up on PA4 powers up the UDA1355 */
	NXP_I2C_Write(sizeof(i2c_UDAmode2), i2c_UDAmode2);
	NXP_I2C_Write(sizeof(i2c_UDAI2SSpdif), i2c_UDAI2SSpdif);
}
#endif
#ifdef USB_AUDIO
#ifdef WIN32
typedef int  (__stdcall *SetPin_type)(unsigned char pinNumber, unsigned short value);
static SetPin_type SetPin;

void InitUsbAudio()
{
    HMODULE hDll;
	int ret;

	/* copied the relevant code from C:\Program Files\NXP\I2C\C\CrdI2c.c
	 */
	hDll = LoadLibrary(L"Scribo.dll");
	if (hDll == 0) {
		fprintf(stderr, "Could not open Scribo.dll\n");
		return ;
	}

	SetPin = (SetPin_type) GetProcAddress(hDll, "SetPin");
	if (SetPin == NULL) {
		FreeLibrary(hDll);
		return; // function not found in library
	}

	ret = SetPin(4, 0x8000); /* Active low on PA4 switches off UDA1355. */
}
#else
void InitUsbAudio()
{
	int fd;
	fd = lxScriboGetFd();
	lxScriboSetPin(fd, 4, 0x8000);
}
#endif
#endif /* USB_AUDIO */

Tfa9887_Error_t	calculateSpeakertCoefA(
										Tfa9887_handle_t handle,
										Tfa9887_SpeakerParameters_t loadedSpeaker)
{
	Tfa9887_Error_t err;
	float re25, tCoefA, tCoef;
	int Tcal; /* temperature at which the calibration happened */
	int T0;
   int calibrateDone = 0;

	err = Tfa9887_DspGetCalibrationImpedance(handle, &re25);
 	assert(err == Tfa9887_Error_Ok);
	assert(fabs(re25) < 0.1); /* no calibration done yet */

	tCoef = tCoefFromSpeaker(loadedSpeaker);

	/* use dummy tCoefA, also eases the calculations, because tCoefB=re25 */
	tCoefToSpeaker(loadedSpeaker, 0.0f);
	load_all_settings(handle, loadedSpeaker, LOCATION_FILES CONFIG_FILENAME, LOCATION_FILES PRESET_FILENAME, LOCATION_FILES EQ_FILENAME);

	/* start calibration and wait for result */
    err = Tfa9887_SetConfigured(handle);
	assert(err == Tfa9887_Error_Ok);

	waitCalibration(handle, &calibrateDone);
   if (calibrateDone)
   {
      Tfa9887_DspGetCalibrationImpedance(handle,&re25);
   }
   else
   {
      printf("Calibration is not done");
      re25 = 0;
   }
	err = Tfa9887_DspReadMem(handle, 232, 1, &Tcal);
	assert(err == Tfa9887_Error_Ok);
	printf("Resistance of speaker is %2.2f ohm @ %d degrees\n", re25, Tcal);

	/* calculate the tCoefA */
	T0 = 25; /* definition of temperature for Re0 */
	tCoefA = tCoef * re25 / (tCoef * (Tcal - T0)+1); /* TODO: need Rapp influence */
	printf("Calculated tCoefA %1.5f\n", tCoefA);

	/* update the speaker model */
	tCoefToSpeaker(loadedSpeaker, tCoefA);

	/* !!! The value is only written to the speaker file “loadspeaker” located in the memory of
    * the host and not in the physical file itself.
    * The physical file will always contain tCoef. The host needs to save tCoefA in this “loadedSpeaker” as it is needed
    * after the next cold boot to write the tCoefA value into MTP !!! */

	return err;
}

static void resetMtpEx(Tfa9887_handle_t handle)
{
	Tfa9887_Error_t err;
	unsigned short mtp;
	unsigned short status;

	/* reset MTPEX bit because calibration happened with wrong tCoefA */
	err = Tfa9887_ReadRegister16(handle, TFA9887_MTP, &mtp);
	assert(err == Tfa9887_Error_Ok);
	/* all settings loaded, signal the DSP to start calibration, only needed once after cold boot */

	/* reset MTPEX bit if needed */
	if ( (mtp & TFA9887_MTP_MTPOTC) && (mtp & TFA9887_MTP_MTPEX))
	{
		err = Tfa9887_WriteRegister16(handle, 0x0B, 0x5A); /* unlock key2 */
		assert(err == Tfa9887_Error_Ok);

		err = Tfa9887_WriteRegister16(handle, TFA9887_MTP, 1); /* MTPOTC=1, MTPEX=0 */
		assert(err == Tfa9887_Error_Ok);
		err = Tfa9887_WriteRegister16(handle, 0x62, 1<<11); /* CIMTP=1 */
		assert(err == Tfa9887_Error_Ok);
	}

	do
	{
		Sleep(10);
		err = Tfa9887_ReadRegister16(handle, TFA9887_STATUS, &status);
		assert(err == Tfa9887_Error_Ok);

	} while ( (status & TFA9887_STATUS_MTPB) == TFA9887_STATUS_MTPB);
	assert( (status & TFA9887_STATUS_MTPB) == 0);

}

static void coldStartup(Tfa9887_handle_t handle)
{
	Tfa9887_Error_t err;
	unsigned short status = 0;
	unsigned short value = 0;
	int tries = 0;

	/* load the optimal TFA9887 in HW settings */
	err = Tfa9887_Init(handle);
	assert(err == Tfa9887_Error_Ok);

	err = Tfa9887_SetSampleRate(handle, SAMPLE_RATE);
	assert(err == Tfa9887_Error_Ok);

	err = Tfa9887_Powerdown(handle, 0);
	assert(err == Tfa9887_Error_Ok);

   printf("Waiting for AMPS and CLKS to start up\n"); // TODO make a clock wait in runtime
	err = Tfa9887_ReadRegister16(handle, TFA9887_STATUS, &status);

   while ( ( (status & TFA9887_STATUS_CLKS) == 0) &&
            (tries < TFA98XX_API_WAITRESULT_NTRIES) )
	{
		/* not ok yet */
		err = Tfa9887_ReadRegister16(handle, TFA9887_STATUS, &status);
		assert(err == Tfa9887_Error_Ok);
      tries++;
	}

   if (tries >= TFA98XX_API_WAITRESULT_NTRIES)
   {
      printf("CLKS start up timed-out\n");
   }
   tries = 0;

   while ( ( (status & TFA9887_STATUS_AMPS) == 0) &&
            (tries < TFA98XX_API_WAITRESULT_NTRIES) )
	{
		/* not ok yet */
		err = Tfa9887_ReadRegister16(handle, TFA9887_STATUS, &status);
		assert(err == Tfa9887_Error_Ok);
      tries++;
	}

   if (tries >= TFA98XX_API_WAITRESULT_NTRIES)
   {
      printf("AMPS start up timed-out\n");
   }
   tries = 0;

   /* some other registers must be set for optimal amplifier behaviour */
   if (Tfa98xx_Error_Ok == err)
   {
      err = Tfa9887_WriteRegister16(handle, TFA9887_CF_CONTROLS, 0x01);
   }

   /* Setting Cool flux enable */
   err = Tfa9887_ReadRegister16(handle, TFA9887_SYS_CTRL, &value);
   assert(err == Tfa98xx_Error_Ok);

   value |= TFA9887_SYSTEM_CONTROL_CFE;/*(1<<2)*/

   err = Tfa9887_WriteRegister16(handle, TFA9887_SYS_CTRL, value);
   assert(err == Tfa98xx_Error_Ok);

   err = Tfa9887_ReadRegister16(handle, TFA9887_STATUS, &status);
   assert(err == Tfa98xx_Error_Ok);

   while ( ( (status & TFA9887_STATUS_AMPS) == 1) &&
            (tries < TFA98XX_API_WAITRESULT_NTRIES) )
	{
		/* not ok yet */
	   err = Tfa9887_ReadRegister16(handle, TFA9887_STATUS, &status);
	   assert(err == Tfa98xx_Error_Ok);
      tries++;
	}
   tries = 0;

   /* Wait for Cool flux to be ready to be released */
   Sleep(10);

   /* Load cold-boot patch for the first time cold start-up*/
   dspPatch(handle, LOCATION_FILES "coldboot.patch");

   err = Tfa9887_ReadRegister16(handle, TFA9887_STATUSREG, &status);

	if ( !(status & TFA9887_STATUS_ACS))
   {
      printf("Not Cold booted");
      return;  /* ensure cold booted */
   }

   /* Enabling the amplifier */
   value |= TFA9887_SYSTEM_CONTROL_AMPE; /*(1<<3)*/

	err = Tfa9887_WriteRegister16(handle, TFA9887_SYS_CTRL, value);

	/* cold boot, need to load all parameters and patches */
	/* patch the ROM code */
   /* Tfa9887 does not have patch at this moment */
	dspPatch(handle, LOCATION_FILES PATCH_FILENAME);

}

static void setOtc(Tfa9887_handle_t handle, unsigned short otcOn)
{
	Tfa9887_Error_t err;
	unsigned short mtp;
	unsigned short status;
	int mtpChanged = 0;

	err = Tfa9887_ReadRegister16(handle, TFA9887_MTP, &mtp);
	assert(err == Tfa9887_Error_Ok);

	assert((otcOn == 0) || (otcOn == 1) );

	/* set reset MTPEX bit if needed */
	if ( (mtp & TFA9887_MTP_MTPOTC) != otcOn)
	{
		/* need to change the OTC bit, set MTPEX=0 in any case */
		err = Tfa9887_WriteRegister16(handle, 0x0B, 0x5A); /* unlock key2 */
		assert(err == Tfa9887_Error_Ok);

		err = Tfa9887_WriteRegister16(handle, TFA9887_MTP, otcOn); /* MTPOTC=otcOn, MTPEX=0 */
		assert(err == Tfa9887_Error_Ok);
		err = Tfa9887_WriteRegister16(handle, 0x62, 1<<11); /* CIMTP=1 */
		assert(err == Tfa9887_Error_Ok);

		mtpChanged =1;

	}
	//Sleep(13*16); /* need to wait until all parameters are copied into MTP */
	do
	{
		Sleep(10);
		err = Tfa9887_ReadRegister16(handle, TFA9887_STATUS, &status);
		assert(err == Tfa9887_Error_Ok);

	} while ( (status & TFA9887_STATUS_MTPB) == TFA9887_STATUS_MTPB);
	assert( (status & TFA9887_STATUS_MTPB) == 0);
	if (mtpChanged)
	{
		/* ensure the DSP restarts after this to read out the new value */
		err = Tfa9887_WriteRegister16(handle, 0x70, 0x1); /* DSP reset */
		assert(err == Tfa9887_Error_Ok);
	}
}

static void statusCheck(Tfa98xx_handle_t handle)
{
	Tfa98xx_Error_t err;
	unsigned short status;

   /* Check status from register 0*/
	err = Tfa9887_ReadRegister16(handle, TFA9887_STATUS, &status);
   if (status & TFA9887_STATUS_WDS)
   {
      printf("DSP watchDog triggerd");
      return;
   }
}

static int checkMTPEX(Tfa9887_handle_t handle)
{
	unsigned short mtp;
	Tfa9887_Error_t err;
	err = Tfa9887_ReadRegister16(handle, TFA9887_MTP, &mtp);
    assert(err == Tfa9887_Error_Ok);

    if ( mtp & (1<<1))	/* check MTP bit1 (MTPEX) */
		return 1;					/* MTPEX is 1, calibration is done */
	else
		return 0;					/* MTPEX is 0, calibration is not done yet */
}

int main(/* int argc, char* argv[] */)
{
	Tfa9887_Error_t err = Tfa9887_Error_Other;
	Tfa9887_handle_t handle;
	int i;
	Tfa9887_Mute_t mute;
	Tfa9887_SpeakerParameters_t lsModel;
	Tfa9887_SpeakerBoost_StateInfo_t stateInfo;
	Tfa9887_SpeakerParameters_t loadedSpeaker;
	float re25;
	float tCoefA;
	unsigned short mtp;
   unsigned char slave_address;
   int calibrateDone = 0;

	/* create handle */
   /* try all possible addresses, stop at the first found */
   for (slave_address = 0x68; slave_address <= 0x6E ; slave_address+=2)
   {
      printf("Trying slave address 0x%x\n", slave_address);
   	  err = Tfa9887_Open(slave_address, &handle);
	    if (err == Tfa9887_Error_Ok)
      {
         break;
      }
   }
   /* should have found a device */
   assert(err == Tfa9887_Error_Ok);

#ifdef SPDIF_AUDIO
	InitSpdifAudio();
#endif
#ifdef USB_AUDIO
	InitUsbAudio();
#endif

	/* When using "tCoefA patch" tCoefA, the loudspeaker model does not need to be saved into by the host anymore*/
	/* tCoefA will be saved into MTP automatically by CoolFlux */
	/* cold boot, need to load all parameters and patches */
   coldStartup(handle);

   /*Set to calibration once*/
   setOtc(handle, 1);

	err = Tfa9887_ReadRegister16(handle, TFA9887_MTP, &mtp);
   assert(err == Tfa9887_Error_Ok);
	printf("MTP = 0x%x\n", mtp);

	loadSpeakerFile(LOCATION_FILES SPEAKER_FILENAME, loadedSpeaker);

   /* Check if MTPEX bit is set for calibration once mode
   /* Calibration always would always do the complete 2 step calibration*/
   if(checkMTPEX(handle) == 0)
	{
		/* ensure no audio during special calibration */
		err = Tfa9887_SetMute(handle, Tfa9887_Mute_Digital);
		assert(err == Tfa9887_Error_Ok);

		printf("still tCoef in speaker file, special calibration needed\n");
		err = calculateSpeakertCoefA(handle, loadedSpeaker);
		assert(err == Tfa9887_Error_Ok);

		resetMtpEx(handle);

		/* force recalibration now with correct tCoefA */
		muteAmplifier(handle); /* clean shutdown to avoid plop */
		coldStartup(handle);

	}
   else
	{
		printf("DSP already calibrated. Calibration skipped and previous calibration results loaded from MTP.\n");
	}

	load_all_settings(handle, loadedSpeaker, LOCATION_FILES CONFIG_FILENAME, LOCATION_FILES PRESET_FILENAME, LOCATION_FILES EQ_FILENAME);

	/* do calibration (again), if needed */
	err = Tfa9887_SetConfigured(handle);
	assert(err == Tfa9887_Error_Ok);
	waitCalibration(handle, &calibrateDone);
   if (calibrateDone)
   {
      Tfa9887_DspGetCalibrationImpedance(handle,&re25);
   }
   else
   {
      printf("Calibration is not done");
      re25 = 0;
   }
   printf("Calibration value is %2.2f ohm\n", re25);

   /*Checking the current status for DSP status and DCPVP */
   statusCheck(handle);

   /*Remark:*/
   /*Reset the MTPEX bit to do the calibration for new speaker*/
   /*resetMtpEx(handle);*/
   /*To verify the tCoefA value, please check tCoefA value from speaker model, please look below*/

	err = Tfa9887_SetMute(handle, Tfa9887_Mute_Digital);
	assert(err == Tfa9887_Error_Ok);
	err = Tfa9887_GetMute(handle, &mute);
	assert(err == Tfa9887_Error_Ok);

	assert(mute == Tfa9887_Mute_Digital);

	/* Start playing music here */
	/* DebugBreak();*/

	err = Tfa9887_SetMute(handle, Tfa9887_Mute_Off);
	assert(err == Tfa9887_Error_Ok);

   /*Starting to retrieve the live data info for 100 loop*/
	for (i=0; i<100; ++i)
	{
		err = Tfa9887_DspSpeakerBoost_GetStateInfo(handle, &stateInfo);
		assert(err == Tfa9887_Error_Ok);
		dump_state_info(&stateInfo);
		Sleep(500);
	}

	/* playing with the volume: first down, then up again */
	for (i=2; i<5; i++)
	{
		float vol;

		printf("Setting volume to %3.1f dB\n", -6.0f*i);
		err = Tfa9887_SetVolume(handle, -6.0f*i);
		assert(err == Tfa9887_Error_Ok);
		err = Tfa9887_GetVolume(handle, &vol);
		assert(err == Tfa9887_Error_Ok);
		assert( fabs(-6.0f*i - vol) < 0.001) ;
		err = Tfa9887_DspSpeakerBoost_GetStateInfo(handle, &stateInfo);
		assert(err == Tfa9887_Error_Ok);
		dump_state_info(&stateInfo);
		Sleep(1000);
	}
	for (i=5; i>=0; i--)
	{
		printf("Setting volume to %3.1f dB\n", -6.0f*i);
		err = Tfa9887_SetVolume(handle, -6.0f*i);
		assert(err == Tfa9887_Error_Ok);
		dump_state_info(&stateInfo);
		Sleep(1000);
	}

	Sleep(5000);

	/* check LS model */
	err = Tfa9887_DspReadSpeakerParameters(handle, lsModel);
	assert(err == Tfa9887_Error_Ok);
   /*Remark: tCoefA value could be get by using the function below to verify the tCoefA value*/
   tCoefA = tCoefFromSpeaker(lsModel);

	err = Tfa9887_SetMute(handle, Tfa9887_Mute_Amplifier);
	assert(err == Tfa9887_Error_Ok);

	err = Tfa9887_Powerdown(handle, 1);
	assert(err == Tfa9887_Error_Ok);

	err = Tfa9887_Close(handle);
	assert(err == Tfa9887_Error_Ok);


	return 0;
}
